<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Fmriants by stnava</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Fmriants</h1>
        <p>Minimal fMRI pre-processing with ANTS</p>
        <p class="view"><a href="https://github.com/stnava/fMRIANTs">View the Project on GitHub <small>stnava/fMRIANTs</small></a></p>
        <ul>
          <li><a href="https://github.com/stnava/fMRIANTs/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/stnava/fMRIANTs/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/stnava/fMRIANTs">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="fmriants" class="anchor" href="#fmriants" aria-hidden="true"><span class="octicon octicon-link"></span></a>fMRIANTs</h1>

<p>Minimal fMRI pre-processing with ANTS</p>

<p>Let's first define some data and create an average (target) image.</p>

<pre><code>fmri=data/bold.nii.gz
nm=data/AFFINE
ref=${nm}_avg.nii.gz
antsMotionCorr -d 3 -a $fmri -o $ref
</code></pre>

<p>The variable <code>$ref</code> is the target image (fixed image) to which we will motion
correct.</p>

<p>Let's do affine motion correction first.</p>

<pre><code>antsMotionCorr  -d 3 \
-o [ ${nm}, ${nm}.nii.gz,${nm}_avg.nii.gz] \
-m MI[${ref}, ${fmri}, 1 , 32 , Regular, 0.1  ] \
-t Affine[ 0.1 ] -u 1 -e 1 -s 1x0 -f 2x1 \
-i 15x3 -n 3  -w 1
</code></pre>

<p>This is a 'fast' example - you might change <code>-i</code> parameters
to something larger and <code>Regular, 0.1</code> to <code>Regular, 0.2</code> for 'real' data.</p>

<p>The parameter <code>-w 1</code> means write out the displacement field.  This will
write a 4D displacement field that captures the affine induced motion
at each voxel.  This can be used to concatenate space-time transformations
or to control for motion, statistically, in a spatially varying way.</p>

<p>Now we create a 4D target image for 4D motion deformable motion correction.
First, parse the header information to find out the number of time points.</p>

<pre><code>hislice=`PrintHeader $fmri | grep Dimens | cut -d ',' -f 4 | cut -d ']' -f 1`
tr=`PrintHeader $fmri | grep "Voxel Spac" | cut -d ',' -f 4 | cut -d ']' -f 1`
</code></pre>

<p>Replicate the fixed 3D image <code>hislice</code> times to make a new 4D fixed image.</p>

<pre><code>fxd=${nm}_fixed.nii.gz
ImageMath 3 $fxd ReplicateImage ${nm}_avg.nii.gz $hislice $tr 0
</code></pre>

<p>Finally, run SyN to map the time series to this fixed space.</p>

<pre><code>tx=SyN[0.1,3,0.0] # critical parameters (though others matter too)
antsRegistration --dimensionality 4 -f 1 -r ${nm}Warp.nii.gz \
      --output   [${nm}_,${nm}Warped.nii.gz] \
      --interpolation Linear --use-histogram-matching 1 \
      --winsorize-image-intensities [0.005,0.995] --transform $tx \
      --metric meansquares[${fxd},$fmri,1] \
      --convergence [15x2,1e-6,4] --shrink-factors 2x1 \
      --smoothing-sigmas 1x0vox --restrict-deformation 1x1x1x0
</code></pre>

<p>The parameter <code>--restrict-deformation 1x1x1x0</code> prevents deformation across time.</p>

<p>Finally, we generate a 3D transformation to a template then replicate these maps s.t. they can be applied to the original 4D dataset.  This is a useful
example of how ANTs works, in general, to minimize the number of interpolations
that one must apply to the data.</p>

<pre><code>antsRegistrationSyNQuick.sh -d 3 -f data/template.nii.gz -m ${nm}_avg.nii.gz \
  -o ${nm}_diff -t s
</code></pre>

<p>Use <code>antsApplyTransforms</code> to combine the displacement field and affine matrix
into a single concatenated transformation stored as a displacement field.</p>

<pre><code># collapse the transformations to a displacement field
antsApplyTransforms -d 3 -o [${nm}_diffCollapsedWarp.nii.gz,1] \
  -t ${nm}_diff1Warp.nii.gz -t ${nm}_diff0GenericAffine.mat \
  -r data/template.nii.gz
</code></pre>

<p>Replicate the 3D template to 4D and apply all the transformations to the
original BOLD data.</p>

<pre><code>ImageMath 3 ${nm}_diff4DCollapsedWarp.nii.gz ReplicateDisplacement \
  ${nm}_diffCollapsedWarp.nii.gz $hislice $tr 0
ImageMath 3 data/template_replicated.nii.gz ReplicateImage \
  data/template.nii.gz $hislice $tr 0
# apply to original bold
antsApplyTransforms -d 4 -o ${nm}_bold2template.nii.gz \
  -t ${nm}_diff4DCollapsedWarp.nii.gz -t ${nm}_0Warp.nii.gz  \
  -r data/template_replicated.nii.gz -i ${nm}Warped.nii.gz
</code></pre>

<p>Next you can run the CompCor command to estimate physiological nuisance variables.</p>

<pre><code>#
# CompCor needs a mask --- you can get the mask by (might need to alter the value 200 up or down)
#
ThresholdImage 3  data/AFFINE_avg.nii.gz data/mask.nii.gz 200 1.e9
ImageMath 3 data/mask.nii.gz ME data/mask.nii.gz 1
ImageMath 3 data/mask.nii.gz GetLargestComponent data/mask.nii.gz
ImageMath 3 data/mask.nii.gz MD data/mask.nii.gz 2
ImageMath 3 data/mask.nii.gz ME data/mask.nii.gz 1
# you may alternatively run CompCor on the motion-corrected data
ImageMath 4 data/OUT.nii.gz CompCorrAuto data/bold.nii.gz data/mask.nii.gz 6
#
</code></pre>

<p>For use in context with T1 processing : see</p>

<p><a href="http://jeffduda.github.io/NeuroBattery/">NeuroBattery</a></p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/stnava">stnava</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>