{"name":"Fmriants","tagline":"Minimal fMRI pre-processing with ANTS","body":"fMRIANTs\r\n========\r\n\r\nMinimal fMRI pre-processing with ANTS\r\n\r\n```\r\nfmri=data/bold.nii.gz\r\nnm=data/AFFINE\r\nref=${nm}_avg.nii.gz\r\nantsMotionCorr -d 3 -a $fmri -o $ref\r\nantsMotionCorr  -d 3 \\\r\n-o [ ${nm}, ${nm}.nii.gz,${nm}_avg.nii.gz] \\\r\n-m MI[${ref}, ${fmri}, 1 , 32 , Regular, 0.1  ] \\\r\n-t Affine[ 0.1 ] -u 1 -e 1 -s 1x0 -f 2x1 \\\r\n-i 15x3 -n 3  -w 1\r\n# -w 1 means write out the displacement field\r\n#\r\n# this is a 'fast' example -\r\n# you should change -i parameters to something larger\r\n# and Regular, 0.01 to Regular, 0.2 for 'real' data -\r\n# see AFFINE_AND_DEFORMABLE below\r\n#\r\n###\r\n### use antsRegistration - must create 4D target\r\n###\r\nhislice=`PrintHeader $fmri | grep Dimens | cut -d ',' -f 4 | cut -d ']' -f 1`\r\ntr=`PrintHeader $fmri | grep \"Voxel Spac\" | cut -d ',' -f 4 | cut -d ']' -f 1`\r\nfxd=${nm}_fixed.nii.gz\r\nstackavg=\" \"\r\nfor x in `seq 1 $hislice` ; do\r\n  stackavg=\" $stackavg ${nm}_avg.nii.gz \"\r\ndone\r\nImageMath 4 $fxd TimeSeriesAssemble $tr 0 $stackavg\r\ntx=SyN[0.1,3,0.0] # critical parameters (though others matter too)\r\nantsRegistration --dimensionality 4 -f 1 -r ${nm}Warp.nii.gz \\\r\n      --output   [${nm}_,${nm}Warped.nii.gz] \\\r\n      --interpolation Linear --use-histogram-matching 1 \\\r\n      --winsorize-image-intensities [0.005,0.995] --transform $tx \\\r\n      --metric meansquares[${fxd},$fmri,1] \\\r\n      --convergence [15x2,1e-6,4] --shrink-factors 2x1 \\\r\n      --smoothing-sigmas 1x0vox --restrict-deformation 1x1x1x0\r\n### generate a 3D transformation to a template then replicate these maps s.t.\r\n### they can be applied to a 4D dataset\r\nantsRegistrationSyNQuick.sh -d 3 -f data/template.nii.gz -m ${nm}_avg.nii.gz \\\r\n  -o ${nm}_diff -t s\r\n# collapse the transformations to a displacement field\r\nantsApplyTransforms -d 3 -o [${nm}_diffCollapsedWarp.nii.gz,1] \\\r\n  -t ${nm}_diff1Warp.nii.gz -t ${nm}_diff0GenericAffine.mat \\\r\n  -r data/template.nii.gz\r\n# replicate 3D to 4D\r\nImageMath 3 ${nm}_diff4DCollapsedWarp.nii.gz ReplicateDisplacement \\\r\n  ${nm}_diffCollapsedWarp.nii.gz $hislice $tr 0\r\nImageMath 3 data/template_replicated.nii.gz ReplicateImage \\\r\n  data/template.nii.gz $hislice $tr 0\r\n# apply to original bold\r\nantsApplyTransforms -d 4 -o ${nm}_bold2template.nii.gz \\\r\n  -t ${nm}_diff4DCollapsedWarp.nii.gz -t ${nm}_0Warp.nii.gz  \\\r\n  -r data/template_replicated.nii.gz -i ${nm}Warped.nii.gz\r\n###########################################\r\n###########################################\r\n### now do deformable motion correction ###\r\n###########################################\r\nnm=data/AFFINE_AND_DEFORMABLE\r\nantsMotionCorr  -d 3 -o [ ${nm}, ${nm}.nii.gz,${nm}_avg.nii.gz] \\\r\n-m MI[${ref}, ${fmri}, 1 , 32 , Regular, 0.2  ] \\\r\n-t Affine[ 0.1 ] -u 1 -e 1 -s 1x0 -f 2x1 -i 33x20 \\\r\n-n 3  -m MI[${ref}, ${fmri}, 1 , 32 ] \\\r\n-t GaussianDisplacementField[0.15,3,0.5] \\\r\n-i 33x20 -u 1 -e 1 -s 1x0 -f 4x1 -n 3\r\n```\r\n\r\nThe csv and result images that come out contain the motion corrected image and the motion nuisance variables - but you need to run the affine version to get the motion variables ( that's a small bug in that the 2nd level registration doesnt maintain the 1st level motion results ) .... It might be interesting to also write out the deformation field in order to quantify distortion but that is a separate issue.\r\n\r\nNext you can run the CompCor command to estimate physiological nuisance variables.\r\n\r\n```\r\n#\r\n# CompCor needs a mask --- you can get the mask by (might need to alter the value 200 up or down)\r\n#\r\nThresholdImage 3  data/AFFINE_avg.nii.gz data/mask.nii.gz 200 1.e9\r\nImageMath 3 data/mask.nii.gz ME data/mask.nii.gz 1\r\nImageMath 3 data/mask.nii.gz GetLargestComponent data/mask.nii.gz\r\nImageMath 3 data/mask.nii.gz MD data/mask.nii.gz 2\r\nImageMath 3 data/mask.nii.gz ME data/mask.nii.gz 1\r\n# you may alternatively run CompCor on the motion-corrected data\r\nImageMath 4 data/OUT.nii.gz CompCorrAuto data/bold.nii.gz data/mask.nii.gz 6\r\n#\r\n# the important output will be called  OUT_compcorr.csv\r\n#\r\n```\r\n\r\nFor T1 processing : see\r\n\r\n[NeuroBattery](http://jeffduda.github.io/NeuroBattery/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}